应用领域：
- 数据分析——爬虫
    - [财经数据包TuShare](https://mp.weixin.qq.com/s?__biz=MjM5MDEyMDk4Mw==&mid=2650166012&idx=1&sn=ab577b80c7b3a261ce3b701a816bb639&scene=21#wechat_redirect) 
- 游戏开发——PGame
    - 比大小（列表）
    - 井字棋
    - 打飞机
    - 贪吃蛇
    - 八分音符——练习好声音ktv
    - 魔塔
    - 模拟科二——欧卡
- 网站建设——PythonWeb
    - 线上、线下、商城、游戏（道具实体，场景再现）    
- PC工具
    - 清理垃圾文件
    - 下载器
    
路线：


######Python2和Python3的区别
- print和input
    - 必须加括号，如：print()默认换行; 增加end参数可以不换行 print("*", end="")
    - input()获取的为String类型的值
- 打开文件不再支持file方法，只能使用open
- range不再返回列表，而是一个可迭代的range对象
- / 结果为浮点数，整除为//
- urllib和urllib2合并为urllib
    - 常用的urllib.urlopen()变成urllib.request.urlopen()
- 字符串和编码
    - [结合循环语句打印各种*图形](https://www.runoob.com/w3cnote/prints-diamonds-triangles-rectangles.html)
        

######编码问题
- ASCII：美国信息交换标准代码,全称American Standard Code for Information Interchange
- Unicode
  - Utf-8
- [GB2312-80：1980年第2312号国家标准](http://www.gb688.cn/bzgk/gb/newGbInfo?hcno=5664A728BD9D523DE3B99BC37AC7A2CC)
  - GBK： (中国)国家标准编码扩展字符集--国标扩展字符集,全拼 GuoBiaoKuo

- 扩展1：Python提供对于单个字符的函数
  - ord()函数获取当前字符集下字符的整数表示
  - chr()函数把当前编码转换为对应字符表示
  - encode()函数可以通过指定的编码生成bytes值
  - decode()函数可以把bytes按照字符集转换为对应字符
  
```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
```
- 扩展2：Python文件头部注释含义
  - 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；
  - 第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。  
  
- 扩展3：Python同C一样，可以使用%来进行格式化输出
  - %d 表示整数 ```print("从%d到%d的和为%d" %(1,100,5050))```
    - 一条语句中多个格式输出,占位的%和括号中的值在数量上必须相等，类型也要匹配。
  - %f 表示浮点数
    - 浮点数可以指定小数位数 ```print("从%.1f"%(1))```
  - %s 表示字符串
  - %x 表示16进制

---
######数据类型——元素是否重复，有序，可变
1. list：列表，一种有序集合，可以随时添加和删除其中元素，元素类型可以是不同的
    - 样子有些像Java中的数组，所有的子元素用[ ]包裹
    - IndexError 角标越界
    - 常用操作：len(),append(),pop(),insert(),del()
2. tuple: 元组，一种有序集合与List类似，但是一旦初始化，不可修改，元素的内存指向不变
    - tuple中元素不可变，当定义一个tuple时，其中的元素必须确定下来 
    - tuple中只有一个元素时，为了避免歧义，元素后面必须添加,号。 ```t = (1,)```
    - tuple中元素可以是list，而list中子元素是可变的，与 元组不可修改不矛盾
3. dict: 字典，其他语言中叫做map，使用key-value来存储，查找速度快，空间占用大，是用空间换时间的一种数据结构
    - 特点：
        - 查找和插入的速度快，不会随着key的增加而降低
        - key 必须是不可变对象，通过key利用哈希算法来计算value存放位置
        - 内部存储的顺序和key放入的顺序是无关的，无法通过索引来访问字典中的某一项，要通过键来访问
            - 如果键是字符串，那么获取对应值的时候，需要添加引号；如果键是数字，则不用
        - 可以通过for...in...来遍历来获取值（字典中的键值）    
    - 常用操作：`d = {"k1":"gk5","k2":3,"k3":["a45","m6"]} `
        - 删除键pop，del
            - del d["k1"]
            - d.pop("k1")
        - 判断是否存在
            - in `"k1" in d`
            - get()
4. set: 集合，同dict一样，也是key-value形式，但是不存储value
    - 特点：
        - 元素不重复
    - 常用操作
        - 添加元素
            - add(key)
        - 删除元素
            - remove(key)
```
# List
classMate = ["A",'B','C']

# Tuple
t = ('1','2',classMate)
print(t)

# 删除列表中元素
t[2].pop(1)
print(t)
```
---
###### 控制结构：顺序，分支，循环
*程序设计通过这三种控制结构来实现，递归属于一种特殊的循环结构*
- 关键字
    - 分支判断:
        - if-else
        - if-elif-else
    - 循环语句：
        - for-in 常用range()函数，list，tuple等一起使用
        - while 指定循环条件
        - continue 跳出当前循环轮，直接开始下一轮循环
        - break 终结所有循环
        
---
###### 函数：基本用法，内建函数，高级特性，函数式编程    
*函数是一种代码抽象的方式，数学意义上的函数：给定一个输入，就会有唯一输出的对应关系*    
- 基本用法
    - 函数调用：需要知道函数名和接收参数
        - [官方文档](http://docs.python.org/3/library/functions.html)
        - 交互帮助命令 help(function_name)：支持python内置函数的查看
    - 函数名：就是对函数对象的引用，可以把一个函数名赋予另一个变量，相当于给函数取一个别名    
    - 参数：运行函数需要接受的数据类型和个数；如有必要，可在函数体中增加参数类型检测
        - TypeError：调用失败的错误信息
            - 参数个数错误
            - 参数类型错误
    - 如何定义一个函数：
        - 函数头：使用def关键字，后面依次写出 函数名，小括号，括号内参数，冒号
            - 位置参数：调用参数时，传入的值按照顺序依次赋给形参。`定义函数power(x,n) 求x的n次幂，此时两者为位置参数`
            - 默认参数：`power(x n=2) 将参数n默认设置为2`
                - 必选参数在前面，默认参数在后面；*思考为什么默认参数不能在前面？*
                    - 定义参数默认值的函数可以在调用时更加简洁。
                    大量 Python 模块中的方法都运用了这一方式，让使用者在调用时可以提供尽可能少的参数
                - 默认参数必须指向不变对象 `int,str,None,……`
            - 可变参数：传入的参数个数是可变的 `calc(*numbers) 函数内部接收的number是一个tuple`
                - 在变量前加上星号前缀（*），调用时的参数会存储在一个 tuple（元组）对象中，
                赋值给形参。在函数内部，需要对参数进行处理时，只要对这个 tuple 类型的形参（这里是 args）进行操作就可以了。
                - 要注意，tuple 是有序的，所以 args 中元素的顺序受到赋值时的影响
            - 关键字参数：传入0个或者任意个含有参数名的参数，这些关键字参数在函数内部自动组装为一个dict
                - 命名关键字参数：限制关键字参数的名字，命名关键字参数需要一个特殊的分隔符*
                - 字典是无序的，所以在输出的时候，并不一定按照提供参数的顺序。同样在调用时，参数的顺序无所谓，只要对应合适的形参名就可以了。于是，采用这种参数传递的方法，可以不受参数数量、位置的限制    
            - 参数组合,在混合使用时，首先要
                - 注意函数的写法，必须遵守：
                    - 带有默认值的形参(arg=)须在无默认值的形参(arg)之后；
                    - 元组参数(*args)须在带有默认值的形参(arg=)之后；
                    - 字典参数(**kargs)须在元组参数(*args)之后。
                - 调用时也需要遵守:
                    - 指定参数名称的参数要在无指定参数名称的参数之后；
                    - 不可以重复传递，即按顺序提供某参数之后，又指定名称传递。
                - 函数被调用时，参数的传递过程为：
                    - 按顺序把无指定参数的实参赋值给形参
                    - 把指定参数名称(arg=v)的实参赋值给对应的形参
                    - 将多余的无指定参数的实参打包成一个 tuple 传递给元组参数(*args)
                    - 将多余的指定参数名的实参打包成一个 dict 传递给字典参数(**kargs)    
        - 函数体写在冒号下方的缩进块中 
            - 空函数 pass语句
            - 自定义参数类型检测 isinstance() -- raise TypeError() 
        - 返回值用return语句
            - 一旦执行到return语句，就表示函数执行完毕，并返回结果
            - 未定义默认return None
            - 返回多个值：本质返回的是一个tuple
- 递归函数
    - 一个函数的内部调用自身本身，这个函数就是递归函数
    - 注意事项
        - 使用递归函数要防止栈溢出
        - 尾递归优化：在函数返回的时候，调用自身本身
            - Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。
    - 场景：阶乘，汉诺塔

- 正则表达式：找寻文本规则的代码
    - 场景：利用正则规则来搜索文本，re是python中的正则表达式模块
    - 元字符表达式
        - `\b` 占位符
        - `[]`
        - `r` 是raw的意思，表示对字符串不进行转义
        - `.` 在正则表达式中，除了换行符以外的任意字符
            - `\S` 在正则表达式中，与除了空白符以外的任意字符，注意是大写的S
        - `*` 表示任意数量，它表示前面的字符可以重复任意多次（包括0次）
            - 在匹配中会尽可能的选择长的结果，如果需要短的结果就停止需要使用`?`
            - `+` 表示一个或者更长
            - {len} 限定长度为len    
- 调试程序：
    - 细读错误提示
    - 输出调试信息，print、Log
        - 通过输出调试信息，可以有效地缩小范围、定位错误发生的位置，确认错误发生时的场景，进而找出错误原因。    
- Python的高级特性    
`在Python中，代码越少越简单越好，代码越少，开发效率越高；可维护的代码长度是固定的`
    - and-or真正的技巧在于，确保a的值不会为假。最常用的方式是使 a 成为 [a] 、 b 成为 [b]，然后使用返回值列表的第一个元素：
        - `a = ""`
        - `b = hell`
        - `c = (True and [a] or [b])[0]`
        - `print c `
    - 切片操作：取List或者Tuple中元素的常见操作方法,同样适用于Str字符串
        - 取前N个元素，也就是索引为0-(N-1)的元素 `L[0, N-1]`
            - 如果第一个索引是0，可以简写为 `[:N-1]`
        - 取倒数第N个元素 `L[-N], eg:倒数第一个元素L[-1]`
        - 切片符 :
            - 取前10个元素 `L[:10]`
            - 取后10个元素 `L[:-10]`
            - 取前10-20个元素 `L[10:20]`
            - 前10个元素，每两个取一个 `L[:10:2]`
            - 所有的元素，每5个取一个 `L[::5]`
            - 复制一个list `[:]`
        - 切片练习：利用切片操作，实现一个trim()函数，去除字符串首尾的空格，注意不要调用str的strip()方法：
    - 迭代操作：通过 `for …… in`来完成
        - 通过collections模块的Iterable类型判断：是否为可迭代类型
            - `from collections import Iterable`
            - `isinstance([1,2,3], Iterable)`
        - 任何可迭代对象都可以作用于for循环，包括我们自定义的数据类型，只要符合迭代条件，就可以使用for循环。
            - list, tuple, str `for i in list`
            - dict  
                - 默认使用key来进行迭代 `for key in dict` 
                - 也可以使用value来进行迭代 `for value in dict.values()`
                - 同时迭代key和value `for k, v in dict.items()`
            - 内置enumerate函数，可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：
                - `for i, value in enumerate([1,2,3])`
                - &ensp;&ensp;`print(i, value)`                    
            - 同时迭代两个变量: 
                - `for x, y in [(1,1),(2,4),(3,9)]`
                - &ensp;&ensp;`print(x,y)`
    - 列表生成式：Python内置用来创建List的生成式
        - 语法：[]包裹内for……in循环
        - 示例场景：
            - 生成10以内的元素的平方 `[x * x for x in range(1,11)]`
            - 筛选出上述中的偶数的平方 `[x * x for x in range(1,11) if x % 2 == 0]`                 
            - 两层循环，生成全排列 `[m + n for m in 'ABC' for n in 'XYZ']`
            - 列出当前目录下，所有文件和目录名 `# os.listdir列出文件和目录` 
                - `import os`
                - `[d for in os.listdir('.')]`
            - 同时迭代dict中的key和value `k + '=' + v for k, v in d.items() `
        - 注意事项：
            - 列表生成式中三层和三层以上的循环很少用            
        - 练习：list中所有字符变成小写
            - 注意，如果list中既包括字符串，又包含整数，由于非字符串没有lower()方法，列表生成式会报错，需要现在类型判断是不是字符串
    - 生成器：一边循环一边计算的机制称为生成 generator。相比生成式，更节省空间
        - 工作原理：在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。遇到return语句或者执行到函数体最后一句，就是结束generator指令，for循环随之结束                 
        - 语法：
            - 定义一个generator
                - ()包裹上for……in循环
                - 使用yield关键字    
                    `def fib(max):`    
                    &ensp; `n,a,b=0,0,1`    
                    &ensp; `while n < max:`    
                    &ensp;&ensp; `yield b`    
                    &ensp;&ensp; `a,b=b, a+b`    
                    &ensp;&ensp; `n=n+1`    
                    `return done`
            - 如果要逐个获取generator中的下一个返回值，
                - 使用next()
                - for 循环
        - 细节
            - 与普通函数的执行顺序不同
                - 普通函数是顺序执行，遇到return或者最后一行语句就返回
                - 变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回。再次执行时从上次返回的yield语句处继续执行。                
    - 迭代器与可迭代类型：可以被next()函数调用并不断返回下一个值的对象称为迭代器Iterator
        - 凡是可以用于for循环的都是Iterable 可迭代类型
        - 凡是作用与next()函数对象都是Iterator 迭代器类型，它们表示一个惰性计算的序列
            - 可以直接用for循环的数据类型：集合数据类型，generator。
            - 可以使用isinstance()来判断对象是否是Iterator
    - 函数式编程：函数面向过程的程序设计的基本单元，允许函数本身作为一个参数传入另一个函数，还允许返回一个参数！函数式编程指这种高度抽象的编程范式。            
        - 高阶函数:Higher-order function
            - 传入参数
                - 函数名其实就是指向函数的变量，函数名也可以指向其他对象；`当内置函数被指向对象时，内置函数功能失效，要重启python交互环境才会恢复` 
                - 函数本身赋值给变量 `绝对值abs()为python的一种内置函数；将函数指向变量 x = abs`
                - 变量可以指向函数，函数的参数也可以接受变量，那么一个函数就可以接受另一个函数作为参数，这种函数就是称之为高阶函数
                - `高阶函数示例：计算两个数字的绝对值之和，abs作为一个参数传入函数中`    
                `def add(x,y,f):`    
                `return f(x) + f(y)`    
                `函数调用输出 print(add(-1,5,abs))`
            - 返回函数
                - 在函数内部再定义一个函数，将结果返回给内部函数，此时该内部函数并未执行
                    - 内部函数可以引用外部函数的参数和局部变量
                    - 当外部函数被调用的时候，每次都会返回一个新的内部函数，即使它接收相同的参数
                - 闭包：当外部参数和变量都包含在返回的内部函数中，这种程序结构被称为闭包
                    - 返回闭包时要注意：返回函数不要任何循环变量，或者后续会发生变化的变量
        - 内置高阶函数,结合lambda表达式进一步简化 
            - map()和reduce():
                - map()接收两个参数，一个是函数，一个是可迭代类型 Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterable返回。
                - reduce()也接收两个参数，把一个函数作用在一个序列上，这个函数必须接收两个参数。
    - 匿名函数：也被称为lambda表达式，不用写return，返回值就是该表达式的结果
        - 匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量
        - 理解：其实就是将def(参数列表)：    改为    lambda 参数列表:
            - ```def f(x)```
            - &ensp;```return x * x```
            - 同 `lambda x: x * x`
        - 注意事项:lambda 表达式其实只是一种编码风格，这种写法更加 pythonic,这并不意味着你一定要使用它,
        了解 lambda 表达式还有一个重要作用就是，看懂别人写的代码。
            - 定义 lambda 表达式时，参数列表周围没有括号，返回值前没有 return 关键字，也没有函数名称。
            - 它的写法比 def 更加简洁。但是，它的主体只能是一个表达式，不可以是代码块，甚至不能是命令（print 不能用在 lambda 表达式中）。所以 lambda 表达式能表达的逻辑很有限。                
            - 可以把lambda表达式可以在def函数定义中
                - `def fn(x)`
                    - `return lambda y: x + y`
                - fn 函数的返回值是一个 lambda 表达式，也就等于是一个函数对象。当以参数2来调用 fn 时，得到的结果就是lambda y: 2 + y
                - a(3) 的结果就是5    
    - 装饰器：在代码运行期间动态增加功能的方式，本质是一个返回函数的高阶函数
        - 装饰模式
    - 偏函数：把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。
    - 常见内置函数：
        - map 是 Python 自带的内置函数，它的作用是把一个函数应用在一个（或多个）序列上，把列表中的每一项作为函数输入进行计算，再把计算的结果以列表的形式返回
            - `lst_1 = [1,2,3,4,5,6]`
            - `lst_2 = [1,3,5,7,9,11]`
            - `lst_3 = map(lambda x,y:x+y,list_01,list_02)`
            - `print(list(lst_3))`
        - zip 函数：
            - `lst_1 = [1,2,3,4,5,6]`
            - `lst_2 = [1,3,5,7,9,11]`
            - `lst_3 = zip(lst_1, lst_2)`
            - `print(list(lst_4))`
---
######  包与模块
- 包：模块的上层组织，可以看做是一文件夹。
    - 包中必须含一个__init__.py文件，否则会被当做普通目录，而不是包结构目录
    - 文件__init__.py可以是空文件，也可以有python代码；
        - 一般会有哪些代码写入__init__.py文件中？作用是什么？
        - [释疑](https://www.cnblogs.com/Lands-ljk/p/5880483.html)
            - 文件__init__.py的作用是控制包的导入行为
            - 当我们导入一个包时，通常导入的是其__init__.py文件，我们可以在__init__.py文件中，批量导入我们所需的模块
            - 文件__init__.py中，可设置一个变量__all__它用来将模块全部导入
    - 文件__init__.py本身一个模块，它的模块名就是包名
    - 细节：自定义的模块名不能与系统自带的模块名冲突，否则将无法导入系统自带的模块
- 模块：在Python中，每一个包含函数和变量的.py文件就称之为一个模块
    - 原因：为了更好的维护代码，把函数进行分组，放到不同的文件中
    - 使用：通过import来导入指定模块 `import random *` or `from random import randint`
        - 使用模块内的方法——模块名.方法名 `random.randint(1,5)` or `randint(1,5)`
        - 通过dir()可以查看模块内有哪些方法 `dir(random)`
        - 只用到某一个函数或者变量时，推荐使用 from···import···
            - 为了方便理解和使用，可以给引入的函数或者变量起一个其他的名字 `from math import pi as math_pi`
    - 好处：提高代码的维护性；方便调用，进行功能扩展；避免函数名与变量名冲突
    - 细节：函数命名不要同Python内置函数名相同。
        - 在命令行运行此.py文件时，Python解释器会将__name__变量置为__main__，此时便可执行代码
        - 当其他地方导入该模块时，if判断将失效。通过模块.方法名()调用方式，才会执行对应方法
            - ```eg:test09.py```
- 常见模块
    - sys模块：sys.argv 表示sys中argv变量 
        - 通过List存储命令行中所有的变量，第一个永远是该.py文件的名称
- 安装第三方模块：
    - 安装方式
        - 包管理工具pip
            - Mac和Linux自带pip安装工具 python2和python3分别对应pip2和pip3
            - Window安装时，勾选`pip`和 `Add python.exe to Path`
        - wheel方式安装
        - Anaconda平台安装
            - Anaconda安装的第三方模块会安装在Anaconda自己的路径下，不影响系统已安装的Python目录。
                - Anaconda配合使用PyCharm当编辑器时，注意不同Anaconda环境下安装的python模块不共享，要切换对应环境下的路径
    - 模块加载机制：Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错
        - Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中
---
###### 面向对象编程
- OOP(Object Oriented Programming)：把对象当做一个程序的基本单元，一个对象包含数据——属性和操作数据——方法
    - 面向对象的设计思想是抽取出模板即Class，根据Class(类)创建Instance(实例)
        - 类方法和我们之前定义的函数区别在于，第一个参数必须为self。
        而在调用类方法的时候，通过“对象.方法名()”格式进行调用，而不需要额外提供self这个参数的值。self在类方法中的值，就是你调用的这个对象本身。
        - Python中定义类的关键字为class，后面紧跟类名(通常是大写的)，再后面是(object)表示继承关系
            - 通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。
            - `eg: class Student(object)`
        - 创建实例是通过 类名 () 实现的
            - `eg: Student ()`
        - 通过定义特殊的__init__()方法，可以在实例化的时候进行初始操作
            - 前后各为两个下划线
            - init方法第一个参数永远为self，表示创建的实例自身，但是创建实例时，不需要传，Python解释器自己会把实例变量传进去
        - Python属于动态语言
            - 可以对实例变量绑定任何数据，也可以创建声明新的实例属性
                - `eg：test10.py 其中一个实例新增age属性`
        - 访问限制，以两个下划线开头为私有声明
            - 只有内部可以访问，外部不能访问称为私有。即不能通过 实例名.__来访问
                - 在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。
                - 看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。
                - 双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量
    - 继承
        - 继承的好处，子类可以获取父类的全部功能
        - 动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。
    - 多态
        - 子类覆写父类方法，运行时，执行子类功能
    - 获取对象信息 `eg:test11.py`
        - type(): 判断对应的class类型，包括 基本类型，指向函数或类的变量，判断对象是否包含函数变量
        - isinstance(): 判断继承关系    
        - dir(): 获取一个对象的属性和方法
    - 实例属性和类属性
        - python属于动态语言，根据类创建的实例可以通过实例变量或者self变量，任意绑定属性
        - 实例属性，属于各个实例所有，互补干扰；类属性属于类所有，所有实例共享一个属性
        - 不要为实例属性和类属性取相同的名字，因为实例属性将覆盖掉类属性
        - 限制实例的属性
            - 在类中定义__solts__变量，限制该class实例添加指定属性
            - 限制属性仅仅对当前类的实例起作用，对继承的子类是不起作用的，除非子类也定义__solts__变量
        - @property可以把一个方法变成属性进行调用
            - 定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性
        - 多重继承
            - python允许多重继承，MixIn就是一种常见的设计，只允许单继承的语言，不能使用MixIn的设计
            - 不需要复杂而庞大的继承链，只要选择组合不同类的功能，就可以迅速构造出所需的子类
        - 定制类
            - 形如__xxx__的变量或函数，在Python中是有特殊用途的，实现定制类 `eg：test12.py`    
                - 定制方法__str__(),返回指定的字符串
                - 用于调试服务__repr__()同__str__()一样
                - 返回一个迭代对象，需要实现__iter__()方法，类可以用于for……in循环，获取下一个值__next__()
                - 实现按照下标取出元素__getitem__(),实现切片;元素赋值方法__setitem__();元素删除方法__delitem__()
                - 动态响应未定义的类的方法或属性__getattr__()
                - 直接对实例进行调用__call__()
                    - 判断对象是否是可调用对象通过callable()函数
        - 枚举类
            - 定义常量推荐:枚举类型（Python提供的Enum类来实现）eg:
            定义一个class类型，每个常量都是class类型的一个唯一实例 `test13`
                - 使用Enum需要导包`from enum import Enum` 
            - 声明:关键字Enum
            - 赋值:
                - 直接使用Enum类
                - 自定义类 继承Enum
            - 访问：Enum.Var.Value
            
        - 元类
            - 动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。
            - type()函数可以查看一个类型或变量的类型，接收三个参数
                - class的名称
                - 继承的父类集合，如果只有一个父类，使用tuple单元素写法
                - class的方法名与函数绑定，把函数fn绑定到方法名hello上
            - metaclass:控制类的创建行为，直译为元类。允许你创建类，或者修改类，步骤如下：
                - 先定义metaclass，安装默认习惯，metaclass的类名总以Metaclass结尾，继承类型必须为type，来表明这是一个元类
                - 再创建类
                    - 定义函数__new__()方法
                - 最后创建实例
                - 使用场景，ORM框架——对象-关系映射 
---
###### 错误、调试和测试
关于20/80的一种说法：程序中20%代码是为了实现需求，80%是为了调试修复

- 错误
  - 错误类型
    - 用户输入错误
    - 异常中断
  - 错误处理
    - 返回对应错误码表示是否出错（不推荐，错误码会同函数自身应该返回的正常结果混在一起）
    - try……except……finally处理机制
      - 某些代码可能会出错，就可以使用try来运行这段代码。
      - 如果上述代码运行中出现错误，跳转至except代码块进行错误处理
        - 可以存在多个except来处理不同类型的错误。
        - except后面可接else，如果没有发生错误，会自动执行else。
        - Python的错误其实是class，所有的错误类型都继承BaseException，所以在使用多个except时需要注意其中的子父类关系
      - 如果存在finally代码块，那么无论错误是否被处理，最后都会运行finally下的代码
      - 支持跨越多层调用，比如函数main()调用foo()，foo()调用bar()，结果bar()出错了，这时，只要main()捕获到了，就可以处理
  - 调用栈
    - 错误没有被捕获，会一直向上抛，最后被Python解析器捕获，并打印错误信息；
    - 程序报错时，一定要分析错误的调用栈信息，才好定位错误的问题 
  - 记录错误
    - Python内置logging模块可以记录错误信息 `logging.exception`
  - 抛出错误
    - 先定义一个错误的class，选择好继承关系，然后用raise语句抛出一个错误实例
    - raise语句如果不带参数，就会把当前错误原样抛出
      - 在except中，raise一个Error可以把一种类型的错误，转换为另一种类型
- 调试debug
  - 查看变量值，哪些值是正确的哪些值是错误的；bug——运行没有达到预期情况
    - 打印输出 print()
    - 断言判断 assert
      - 启动python解释器 -O参数，关闭assert
    - **推荐使用日志输出 logging**
      - 使用`import loggint`可以查看详细报错信息
      - 通过设置level来指定级别
      - 支持输出到文件或控制台
  - pdb调试器
    - 单步运行
    - 断点调试
  - IDE比pdb更方便调试
    - VS Code
    - PyCharm
- 单元测试 `test15`
  - 简介
    - 用来对一个模块，一个函数，或者一个类来进行正确性的测试工作
    - 确保一个程序模块的行为符合设计的测试用例
    - 单元测试代码要非常简单，如果测试代码太复杂，那么测试代码本身就可能带有bug
  - 使用
    - 引入Python自带的unittest模块
    - 编写测试类，以test开头方法就是测试方法，不以test开头就不算测试类，测试时不会被执行
    - 测试是否达成期望
      - 输出是否期望使用断言函数
        - 值是否相等 assertEqual()
        - 真假是否 assertTrue()/assertFalse()
      - 错误类型是否为指定类型断言KeyError
        - 异常错误场景 assertRaises(ValueError)
      - setUp()和setDown()可以在每个测试方法前后自动调用
    - 运行单元测试
      - 方法一 `unittest.main()`
      - 方法二 命令行参数 -m unittest `python -m unittest mydict_test`
        - 推荐使用，一次可以运行多个单元测试，很多工具可以自动运行这些单元测试
- 文档测试 `test16`
  - 简介
    - 通过python内置的文档测试模块doctest可以提取注释里的代码并执行测试
    - doctest不但可以用来测试，还可以直接作为示例代码，通过某些文档生成工具，可以自动把doctest的注释提取出来。
  - 使用
    - doctest严格按照python交互式命令行的输入输出来判断测试结果是否正确
      - 当有异常的时候，可以用 `...`表示中间大段烦人的输出
      - 只有命令行直接运行时，才会执行doctest，不用担心会在非测试环境下执行
    - 运行 `doctest.testmod()`
      - 如果doctest运行正确，什么输出也没有；代码错误时，doctest才会报错
      - 命令行运行，IDE会报错
- IO编程：
  - 理解概念 Input、Output、Stream、同步IO、异步IO
- 文件读写
  - 简介：
    1. 读写文件是常见的IO操作，Python内置了读写文件的函数，用法与C是兼容的
    2. 在磁盘上读写文件都是由操作系统提供的，现在操作系统不允许，普通程序直接操作磁盘
    3. 读写文件本质上，请求操作系统打开一个文件对象，然后，通过操作系统提供的接口，
    从文件对象中读取数据，或者把数据写入文件对象中。
  - 读文件
    - 语法：
      1. 通过内置open()函数，传入文件名和标示符： 
      `f = open('F:\OtherProject\PythonProject\tutorial\Python_doc.md','r')`
      2. 如果文件不存在，抛出IOError错误，包含错误码和详细信息
      3. 如果文件存在，调用read()方法，读取文件全部内容
      4. 最后需要调用close()方法来关闭，由于读取可能出现IOError，影响close的执行，推荐使用try……finally来包裹open()操作
          - Python引入了`with`语句自动帮我们调用close()方法
          - read()会一次性读取文件全部内容，防止内存溢出，
          可以反复调用read(size)设置最多读取字节数，
          另外调用readline()可以读取一行的内容，调用readlines()可以一次读取所有内容，并按行返回list。
    - 细节补充
      - Windows下路径需要加转译符
      - file-like Object：像open()函数返回带有read()方法的对象，在python中统称为file-like Object
      - 二进制文件：读取二进制文件如，图片，视频等，需要用`rb`模式打开 `f = open(D:\\My Documents\\Desktop\\PD1816\\01.jpg), 'rb' `
      - 字符编码：对于非UTF-8编码的文本文件，需要结合open()传入encoding参数，例如读取GBK编码的文件：
      `f = open(D:\\My Documents\\Desktop\\PD1816), 'r', encoding='gbk'`
  - 写文件
    - 写文件同读文件一样都是open()函数，区别在于传入标识符 `w` 或者 `wb` 表示写文本文件或者二进制文件。
    `f = open(D:\\My Documents\\Desktop\\PD1816\\readme.txt, 'w')`
    - 系统不会立即全部将数据写入磁盘，只有当close()被调用时，才会将剩余全部写入磁盘。
    防止忘记close(),推荐使用with语句。
    - 传入标识符 `a`代表追加模式，直接传入`w`会直接覆写文件
    - 同写文件一样，传入encoding参数可以将字符串自动转换成指定编码
- 内存读写：数据读写不一定是文件，也可以系统数据在内存中读写
  - StringIO内存读写str
  - BytesIO内存读写二进制数据
  - 细节补充
    - 与文件读取相比，没有open()函数，获取对象后，直接进行读写操作
    - 内存读写操作需要从io包中引入
        - `from io import StringIO`
        - `from io import BytesIO`

- 操作文件和目录
  - 调用操作系统：Python中内置os模块，可以直接调用操作系统提供的接口函数,需要import导入先
    - 获取操作系统名称 `os.name`
    - 查看操作系统详细信息 `os.uname()`
  - 环境变量
    - 查看系统定义的环境环境`os.environ`
    - 获取某个具体key的环境变量值 `os.environ.get('key')`
  - 操作目录
    - 查看目录 `os.path.abspath('.')`
    - 创建目录 `os.mkdir()`
    - 删除目录 `os.rmdir()`
    - 路径操作，不推荐直接拼接字符串，通过系统函数，可以正确处理不同操作系统之间的路径分隔符
    合并、拆分路径的函数并不要求目录和真的存在，只对字符串进行操作
      - 合并路径 `os.path.join()`
      - 拆分路径 `os.path.split()`
  - 操作文件
    - 文件重命名 `os.rename()`
    - 文件删除 `os.remove()`
    - 获取文件扩展名 `os.path.splitext()`
    - 获取当前目录所有文件 `x for x in os.listdir('.') if os.path.isdir(x)`
    - 列出所有.py的文件 `x for x in os.listdir('.') if os.path.isfile(x) and os.path.splistext(x)[1] == '.py' `
  - 补充：文件复制，在os模块中不存在！原因是复制文件并非由操作系统提供的系统调用。
  shutil模块提供了copyfile()的函数；  
---
序列化
  - What：我们把变量从内存中变成存储或可传输的状态称为序列化，就可以写入磁盘或者传输到别的机器上了。
  反过来，序列化之后的对象重新读取到内存中，称为反序列化。
  - Python中的序列化模块：pickle
    - 序列化 :pickle存储方式默认是二进制方式
      - pickle.dumps()方法，可以把任意对象序列化成一个bytes，就可以把这个bytes写入文件
        - with open中需要使用wb模式，且wb模式下不能指定encoding
      - pickle.dump()方法，直接把对象序列化后，写入一个file-like Object
    - 反序列化
      - pickle.loads()方法，用于先把对象读取到bytes中，再反序列化出对象
      - pickle.load()方法，用于直接从file-like Object中直接反序列化出对象
    - 注意事项：
      - 变量序列化前和反序列化后，只是内容相同而已，是两个不相干的对象
      - 使用Pickle需要注意，只用于Python序列化，其他语言不适用
  - 文件传输标准格式：用于不同编程语言间，不同平台之间数据传输。
    - XML
    - Json：python内置json模块
      - str与python对象的互相转换
      
        - dumps()方法返回一个str，内容就是标准的Json；类似的，dump()方法可以直接把Json写入一个file-like Object
        - loads()方法或者的load()方法，前置把字符串反序列化成Json，后者从file-like Object中读取字符并反序列化
      - 为class对象实现序列化
        - 可选参数 default 可以把任意一个对象，变成可序列化为Json的对象。
        - 使用__dict__属性，来存储实例变量
    - [Protobuf](https://yami.io/protobuf/)
---
###### 进程与线程
- overview
  - 概念
    - 多任务系统：可以同时执行多个任务的操作系统，原理CPU快速切换   
    - 线程：系统最小执行单元
    - 进程：至少由一个线程组成任务单元
    - 费曼示例：比如Word程序，它可以同时进行打字、拼写检查、打印等事情。
    在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，
    我们把进程内的这些“子任务”称为线程（Thread）。
    - 注意事项：如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，
    执行多长时间。
  - 多任务实现方式：多线程和多进程的程序，涉及数据同步，共享的问题，编写起来更复杂  
    - 多进程模式
    - 多线程模式
    - 多进程+多线程模式
  - Python实现多进程
    - 操作系统相关
        - Unix/Linux操作系统fork()：调用一次返回两次，
        - multiprocessing：模块就是跨平台版本的多进程模块
            - 创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动
            - join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。
        - Pool：如果需要启动大量子线程，可以采用进程池的方式批量创建子进程
    - 子进程：子进程并不都是自身，很多时候，而是一个外部进程，创建子进程后，还需要控制子进程的输入和输出。
        subprocess模块可以启动一个子线程，控制其输入输出
    - 进程间通信：操作系统提供多种机制来实现进程间实现通信，Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据。    
